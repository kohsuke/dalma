TODO
====
    Use this to replace the build automation
        - write e-mail endPointoint (and qmail endPointoint)
        - figure out how to write the "accept" thread.


	- users should be able to access their own state information easily
	  from Conversation (like Thread)

    - Check out Windows Server 2003 POP3 mail service
    - consider integrating with Exchange Server
    - consider sendmail integration

E-mail Ports
============
    - one interface, multiple implementations
    
Notes
=====
- Ports need to be continuationable.


How to handle hydration/dehydration of conversation?
    specifically, what needs to be programatically reconstructed,
    and what needs to be persisted.

    RECONSTRUCTED
    =============
    IDEA.1
        1. the user "saves" the Engine to an OutputStream
            Engine e = ...;
            e.save(new FileOutputStream(...));
        2. then the user "loads" the Engine with a help of a resolver
            Engine e = EngineFactory.load(new FileInputStream(...),new MyResolverImpl());

        2. what the resolver needs to provide
            Class -> 



        1. the user creates a new Engine instance, specifying the data store.

            Engine e = new Engine(new FileSystemDataStore(...));



	The "save" method model assumes that the shutdown is orderly. While this might be true
	for a JavaSE application, this isn't quite ideal for JavaEE apps, which is often killed
	with Ctrl+C or machine shutdown.
	
	The other model is where the engine always write enough states to the disk so that
	suspended continuations can be recovered even after a crash. Port states are also
	constantly persisted. This is kinda like how Hudson works.
	So when you do new Engine(), it always restores the previous states.
	
	HUDSON MODEL
	============
	Each conversation persists itself (not just continuation) whenever it suspends.
	The idea is that if the shutdown happens while none of the conversation is running,
	this can restore states correctly.
	
	Engine persists itself whenever its state changes (like idgen changes). But
	conversations are restored by looking at file systems and finding them. The same goes
	to ports.
	
	Ports persist themselves whenever their state changes (such as when a new conversation
	parks on it.)
	
	The downside is the performance --- you'll incur a lot of disk access in this way.
	But that can be fixed by saving from another thread asynchronously (but by locking it down.)
	
	Does this work well with JavaSE?