<document>
<properties>
  <title>Tutorial</title>
</properties>
<body>
<section name="Writing a workflow application">
  <p>
    This document explains how you can write a workflow application quickly by using Dalma. This document is a follow-up to <a href="10minutes-guide.html">10 minutes guide</a>.
  </p><p>
    First, use the <tt>dalma:genapp</tt> goal of <a href="maven-dalma-plugin/index.html">Maven Dalma plugin</a> to set up a new workspace. If you'd like to use Ant instead of Maven, see <a href="develop-with-ant.html">this document</a>.
  </p>
</section>
<section name="Closer look at the entry point code">
  <p>
    The entry point of a workflow application can look like the following:
  </p>
<source><![CDATA[
package com.example;

import dalma.Description;
import dalma.Engine;
import dalma.Program;
import dalma.Resource;

@Description("This is a dummy workflow")
public class Main extends Program {
    @Override
    public void main(Engine engine) throws Exception {
        getLogger().log("Started");
    }
}
]]></source>
  <p>
    The <a href="dalma-container/apidocs/index.html?dalma/Program.html">Program</a> class serves as the entry point for Dalmacon. Dalmacon finds this class through the <a href="container/dar.html">Dalma-Main-Class manifest entry</a>, and instanciate this class. The <tt>main</tt> method is called after everything is ready. In the above code, I'm just recording the fact that the code run.
  </p><p>
    <a href="dalma-container/apidocs/index.html?dalma/Description.html">@Description</a> provides a human-readable description of this workflow application. The WebUI uses this information for display.
  </p>
</section>
<section name="Adding an endpoint">
  <p>
    A workflow program isn't very interesting unless it talks to other systems. In Dalma, they are called <a href="endpoint.html">"endpoints"</a>, and Dalma ships with several of them. In this tutorial, we'll use the <a href="dalma-endpoint-email/index.html">e-mail endpoint</a> to write an e-mail based workflow program.
  </p><p>
    First, we have to add a new endpoint to our project.
  </p>
</section>
<section name="Write a simple workflow">
  <p>
    Now we are ready to write a workflow program. Let's write a simple one that just keep replying to the user's message.
  </p>
<source>
package foo.workflow;
import ...;

public class MyWorkflow implements Runnable, Serializable {
  // initial message received
  private MimeMessage msg;
  
  private final EmailEndPoint eep;
  
  public MyWorkflow(EmailEndPoint eep, MimeMessage msg) {
    this.eep = eep;
    this.msg = msg;
  }
  
  public void run() {
    // decide when to stop this workflow. one day from now
    Calendar cal = new GregorianCalendar();
    cal.add(DATE,1);
    Date dt = cal.getTime();
    
    int counter = 0; // pointless counter
    
    do {
        // create a reply message
        msg = msg.reply(false);
        msg.setText(String.valueOf(counter));
        
        // send it and wait for a reply
        msg = eep.waitForReply(msg,dt);
    } while(msg!=null);
  }
}
</source>
  <p>
    A workflow program is simply a <tt>Runnable</tt> object. The <tt>run</tt> method is invoked by the engine, and when this method returns the conversation ends. There will be one instance of this per one running workflow instance (which is called "conversation".)
    It also needs to implement <tt>Serializable</tt>, because when a conversation is suspended, its state is persisted to a disk by using Java serialization.
  </p><p>
    We'll start this conversation when a fresh message is received, so the constructor takes the first message received. The workflow immediately replies to a received message, and waits for the sender to further reply. When your conversation blocks, the engine actually persists its state to disk, and remove your conversation from memory. The Java thread that run it will be used to run other conversations. But this all happens behind the scene, and except for the fact that your objects need to be serializable, this is largely transparent.
  </p><p>
    When a reply is received, your conversation is resumed, and execution returns normally from the <tt>waitForReply</tt> method with a non-null return value. The conversation sends out another reply, and waits for a further reply.
  </p><p>
    Eventually time elapses, and when one day passes, the <tt>waitForReply</tt> method will return with null. At this point the run method exits, and the conversation is considered complete.
  </p>
</section>


  <p>
    A workflow engine isn't very interesting unless it can talk to other systems. In Dalma, they are called <a href="endpoint.html">"endpoints"</a>, and Dalma ships with several of them. In this tutorial, we'll be using the <a href="dalma-endpoint-email/index.html">e-mail endpoint</a>, so let's also copy all the jars from the <tt>email</tt> directory as well.
  </p>
  </subsection>
<source>

  </p>
</section>
<section name="New mail handler">
  <p>
    Finally, we come back to the new mail handler. When an e-mail that is not a reply to any of the running conversations is received by an e-mail endpoint, it's passed to the new mail handler. In this tutorial, we'll simply create a new conversation into the engine.
  </p>
<source>
eep.setNewMailHandler(new NewMailHandler() {
  public void onNewMail(MimeMessage mail) {
    engine.createConversation(MyWorkflow.class, eep, msg);
  }
});
</source>
  <p>
    <b>TODO: this is a lie. we don't have this version of the <tt>createConversation</tt> method. What would be the easy-to-use API in this case? feedback appreciated.</b>
  </p>
</section>
<section name="Run">
  <p>
    That's it. Run this program, and see for yourself that the workflow replies to your e-mail. You can even kill the JVM, restart it, and see that the engine still remembers your running conversations, as if nothing has happened.
  </p><p>
    You can also run this program under the debugger. You can set breakpoints, inspect variables, and pretty much everything works normally. Now you got your first working dalma workflow.
  </p><p>
    <b>TODO: complete source code in a zip file</b>
  </p>
</section>
</body>
</document>